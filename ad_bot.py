import loggingimport adbutilsimport subprocessimport timeimport threading# AI# import os# from sentence_transformers import SentenceTransformer, util# from PIL import Imagefrom common import constants as constfrom common.image_comparator import CompareImage# ---------------------------------#  Loggerlogger = logging.getLogger(__name__)syslog = logging.StreamHandler()formatter = logging.Formatter('[%(levelname)s](%(name)s): %(message)s')syslog.setFormatter(formatter)logger.addHandler(syslog)logger = logging.LoggerAdapter(logger, extra={'app_name': 'embot'})# ---------------------------------# AI#model = SentenceTransformer('clip-ViT-B-32')# def are_images_similar(emulator_device, img_path1, img_path2, threshold):#     logger.debug(f"[{emulator_device.serial}] Comparing images")##     start_time = time.time()##     encoded_image = model.encode([Image.open(img_path1), Image.open(img_path2)], batch_size=256, convert_to_tensor=True)#     mid_time = time.time()#     execution_time = mid_time - start_time#     logger.debug(f"[{emulator_device.serial}] Execution of encode took: {execution_time:.6f} seconds")#     # cosine similarity score#     score = util.paraphrase_mining_embeddings(encoded_image)[0][0]#     are_similar = score > threshold##     end_time = time.time()  # Record the end time#     execution_time = end_time - start_time#     logger.debug(f"[{emulator_device.serial}] Execution of paraphrase_mining_embeddings took: {execution_time:.6f} seconds")##     logger.debug(f"Similarity score is: {score} - similar {are_similar}")##     return are_similar# Toolsdef check_cli_tools_installed():    try:        adb_command = "adb --version"        result = subprocess.run(adb_command, shell=True, capture_output=True)        if "Android Debug Bridge" in str(result.stdout):            logger.debug("ADB is installed.")        else:            raise Exception    except Exception:        logger.warning("ADB is not installed. Please use: brew install android-platform-tools")        exit(1)    try:        convert_command = "convert --version"        result = subprocess.run(convert_command, shell=True, capture_output=True)        if "Version: ImageMagick" in str(result.stdout):            logger.debug("Convert is installed.")        else:            raise Exception    except Exception:        logger.warning("Convert is not installed. Please install")        exit(1)def to_box(dimensions):    return dimensions['left'], dimensions['top'], dimensions['right'], dimensions['bottom']def get_screenshot_path(emulator_device):    return const.SCREENSHOT_PATH_PREFIX + emulator_device.serial + const.IMAGE_EXTENSIONdef get_cropped_screenshot_path(emulator_device, suffix=""):    suffix = "-" + suffix if suffix != "" else ""    return const.CROPPED_SCREENSHOT_PATH_PREFIX + emulator_device.serial + suffix + const.IMAGE_EXTENSIONdef take_screenshot(emulator_device):    logger.info(f"[{emulator_device.serial}] Taking a screenshot")    start_time = time.time()    adb_command = f"adb -s {emulator_device.serial} exec-out screencap -p > {get_screenshot_path(emulator_device)}"    subprocess.run(adb_command, shell=True, check=True)    end_time = time.time()  # Record the end time    execution_time = end_time - start_time    logger.debug(f"[{emulator_device.serial}] Execution of sceenshot took: {execution_time:.6f} seconds")def crop_screenshot(emulator_device, dimensions, suffix):    logger.debug(f"[{emulator_device.serial}] Cropping a screenshot")    start_time = time.time()    # Image.open(get_screenshot_path(emulator_device)).crop(to_box(dimensions)).save(get_cropped_screenshot_path(emulator_device))    crop_cmd = f"convert {get_screenshot_path(emulator_device)} -crop {dimensions['right'] - dimensions['left']}x{dimensions['bottom'] - dimensions['top']}+{dimensions['left']}+{dimensions['top']} {get_cropped_screenshot_path(emulator_device, suffix)}"    subprocess.run(crop_cmd, shell=True, check=True)    end_time = time.time()  # Record the end time    execution_time = end_time - start_time    logger.debug(f"[{emulator_device.serial}] Execution of cropping took: {execution_time:.6f} seconds")def crop_ad(emulator_device):    crop_screenshot(emulator_device, const.TV_IMAGE_DIMENSIONS, const.AD_SUFFIX)def crop_close_ad(emulator_device):    crop_screenshot(emulator_device, const.CLOSE_AD_DIMENSIONS, const.CLOSE_AD_SUFFIX)def crop_menu_button(emulator_device):    crop_screenshot(emulator_device, const.MENU_BUTTON_IMAGE_DIMENSIONS, const.MENU_BUTTON_SUFFIX)def crop_all(emulator_device):    crop_ad(emulator_device)    crop_close_ad(emulator_device)    crop_menu_button(emulator_device)def take_screenshot_and_crop_all(emulator_device):    take_screenshot(emulator_device)    crop_all(emulator_device)def take_screenshot_and_crop_ad(emulator_device):    take_screenshot(emulator_device)    crop_ad(emulator_device)def take_screenshot_and_crop_close_ad(emulator_device):    take_screenshot(emulator_device)    crop_close_ad(emulator_device)def take_screenshot_and_crop_menu(emulator_device):    take_screenshot(emulator_device)    crop_menu_button(emulator_device)def click_on_ad(emulator_device):    logger.debug(f"[{emulator_device.serial}]: clicking AD")    emulator_device.click(const.TV_LOCATION['x'], const.TV_LOCATION['y'])def click_exit_ad(emulator_device):    logger.debug(f"[{emulator_device.serial}]: exiting AD")    emulator_device.click(const.CLOSE_AD_LOCATION['x'], const.CLOSE_AD_LOCATION['y'])def is_emulator_attached(emulator_device):    if emulator_device.info[const.STATE_KEY] == "device":        logger.debug(f"[{emulator_device.serial}] is attached")        return True    else:        logger.error(f"[{emulator_device.serial}] IS OFFLINE")        exit(1)def are_images_similar(emulator_device, first_image, second_image, threshhold):    start_time = time.time()  # Record the start time    compare_image = CompareImage(first_image, second_image)    image_difference = compare_image.compare_image()    logger.debug(f"[{emulator_device.serial}]: Compared ({first_image.split('/')[-1]}) X ({second_image.split('/')[-1]}) difference: {image_difference}")    end_time = time.time()  # Record the end time    execution_time = end_time - start_time    logger.debug(f"[{emulator_device.serial}]: Execution of comparing took: {execution_time:.6f} seconds")    return image_difference < threshholddef is_close_ad_present(emulator_device):    logger.debug(f"[{emulator_device.serial}]: Looking for AD close button")    for image in const.ORIGINAL_CLOSE_AD_IMAGES_PATHS:        if are_images_similar(emulator_device, get_cropped_screenshot_path(emulator_device, "close-ad"), image, const.CLOSE_AD_DIFF_THRESHOLD):            # This is redundant check to make sure its not the main exit button            if not are_images_similar(emulator_device, get_cropped_screenshot_path(emulator_device, "close-ad"), const.DONT_CLOSE_ADD_BUTTON_PATH, const.CLOSE_AD_DIFF_THRESHOLD):                return True    return Falsedef is_ad_present(emulator_device):    logger.debug(f"[{emulator_device.serial}]: Looking for AD")    return are_images_similar(emulator_device, get_cropped_screenshot_path(emulator_device, "ad"), const.ORIGINAL_TV_IMAGE_PATH, const.TV_IMAGE_DIFF_THRESHOLD)def is_in_tavern(emulator_device):    logger.debug(f"[{emulator_device.serial}]: Looking for menu button")    # need to check better for gambler or something    return are_images_similar(emulator_device, get_cropped_screenshot_path(emulator_device, "menu-button"), const.ORIGINAL_MENU_BUTTON_IMAGE_PATH, const.MENU_BUTTON_IMAGE_DIFF_THRESHOLD)def close_ad_if_playing(emulator_device):    logger.debug(f"[{emulator_device.serial}]: close ad if playing")    take_screenshot(emulator_device)    crop_close_ad(emulator_device)    if is_close_ad_present(emulator_device):        logger.debug(f"[{emulator_device.serial}]: closing ad")        click_exit_ad(emulator_device)        time.sleep(2)        close_ad_if_playing(emulator_device)    else:        logger.debug(f"[{emulator_device.serial}]: ad is not playing")        crop_menu_button(emulator_device)        if is_in_tavern(emulator_device):            logger.debug(f"[{emulator_device.serial}]: is in tavern")def watch_ad_and_close_after(emulator_device):    click_on_ad(emulator_device)    time.sleep(5)    close_ad_if_playing(emulator_device)def check_device_loop(emulator):    logger.info(f"Running loop for: {emulator}")    while True:        # check if its online        if is_emulator_attached(emulator):            take_screenshot(emulator)            crop_ad(emulator)            if is_ad_present(emulator):                logger.info(f"[{emulator.serial}]: has AD")                watch_ad_and_close_after(emulator)            else:                close_ad_if_playing(emulator)        else:            logger.error(f"[{emulator.serial}]: is offline")            breakif __name__ == '__main__':    logger.setLevel(logging.DEBUG)    logger.info("Started Shakes_AD_Bot")    # check installed adb    check_cli_tools_installed()    adb = adbutils.AdbClient(host="127.0.0.1", port=5037)    emulator_device_list = adb.device_list()    thread_list = []    if len(emulator_device_list) == 0 or (len(emulator_device_list) == 1 and emulator_device_list[0].info == "offline"):        logger.error("No running emulators, exiting now.")        exit(1)    for device in emulator_device_list:        thread = threading.Thread(target=check_device_loop, args=(device,))        thread.start()        thread_list.append(thread)    try:        while True:            pass    except KeyboardInterrupt:        logger.debug("Program status: Ending program.")        for thread in thread_list:            thread.join()