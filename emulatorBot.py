import threadingimport timeimport numpyimport osimport cv2import subprocessfrom PIL import Imageemulator_list = []EMULATOR_KEY = "emulator"STATE_KEY = "state"# ScreenshotSCREENSHOT_NAME = "screenshot"CROPPED_SCREENSHOT_NAME = "cropped_screenshot"ORIGINAL_TV_IMAGE_NAME = "colorTV.png"ORIGINAL_CLOSE_AD_IMAGE_NAME = "closeAd.png"ORIGINAL_CLOSE_AD_IMAGE_NAME_2 = "closeAd2.png"DIR_PATH = os.path.dirname(__file__)SCREENSHOT_PATH = os.path.join(DIR_PATH, "screenshots", SCREENSHOT_NAME)CROPPED_SCREENSHOT_PATH = os.path.join(DIR_PATH, "screenshots", CROPPED_SCREENSHOT_NAME)ORIGINAL_TV_IMAGE_PATH = os.path.join(DIR_PATH, "original", ORIGINAL_TV_IMAGE_NAME)ORIGINAL_CLOSE_AD_IMAGE_PATH = os.path.join(DIR_PATH, "original", ORIGINAL_CLOSE_AD_IMAGE_NAME)ORIGINAL_CLOSE_AD_IMAGE_PATH_2 = os.path.join(DIR_PATH, "original", ORIGINAL_CLOSE_AD_IMAGE_NAME_2)TV_LOCATION = {'x': 188, 'y': 277}TV_IMAGE_DIMENSIONS = {'left': 110, 'top': 180, 'right': 275, 'bottom': 360}# Close adCLOSE_AD_LOCATION = {'x': 1013, 'y': 55}CLOSE_AD_DIMENSIONS = {'left': 980, 'top': 30, 'right': 1050, 'bottom': 100}class CompareImage(object):    def __init__(self, image_1_path, image_2_path):        self.minimum_commutative_image_diff = 1        self.image_1_path = image_1_path        self.image_2_path = image_2_path    def compare_image(self):        image_1 = cv2.imread(self.image_1_path, 0)        image_2 = cv2.imread(self.image_2_path, 0)        commutative_image_diff = self.get_image_difference(image_1, image_2)        if commutative_image_diff < self.minimum_commutative_image_diff:            print("Matched")            return commutative_image_diff        return 10000    @staticmethod    def get_image_difference(image_1, image_2):        first_image_hist = cv2.calcHist([image_1], [0], None, [256], [0, 256])        second_image_hist = cv2.calcHist([image_2], [0], None, [256], [0, 256])        img_hist_diff = cv2.compareHist(first_image_hist, second_image_hist, cv2.HISTCMP_BHATTACHARYYA)        img_template_probability_match = cv2.matchTemplate(first_image_hist, second_image_hist, cv2.TM_CCOEFF_NORMED)[0][0]        img_template_diff = 1 - img_template_probability_match        # taking only 10% of histogram diff, since it's less accurate than template method        commutative_image_diff = (img_hist_diff / 10) + img_template_diff        return commutative_image_diffdef take_screenshot(emulator_device):    screenshot_path = SCREENSHOT_PATH + "-" + emulator_device[EMULATOR_KEY] + ".png"    adb_command = f"adb -s {emulator_device[EMULATOR_KEY]} exec-out screencap  -p > {screenshot_path}"    subprocess.run(adb_command, shell=True)    # wait for screenshot to be present    time.sleep(1)def crop_screenshot(emulator_device, dimensions):    # Load the two images you want to compare    screenshot_path = SCREENSHOT_PATH + "-" + emulator_device[EMULATOR_KEY] + ".png"    image_before = Image.open(screenshot_path)    cropped_image = image_before.crop(        (dimensions['left'], dimensions['top'], dimensions['right'], dimensions['bottom']))    # Save the cropped image    cropped_screenshot_path = CROPPED_SCREENSHOT_PATH + "-" + emulator_device[EMULATOR_KEY] + ".png"    cropped_image.save(cropped_screenshot_path)    # wait for save    time.sleep(1)def click_on_ad(emulator_device):    print(f"Emulator: {emulator_device[EMULATOR_KEY]} - clicking ad")    perform_click(emulator_device, TV_LOCATION['x'], TV_LOCATION['y'])def click_exit_ad(emulator_device):    print(f"Emulator: {emulator_device[EMULATOR_KEY]} - exiting ad")    perform_click(emulator_device, CLOSE_AD_LOCATION['x'], CLOSE_AD_LOCATION['y'])def perform_click(emulator_device, x_pos, y_pos):    adb_command = f"adb -s {emulator_device[EMULATOR_KEY]} shell input tap {x_pos} {y_pos}"    subprocess.run(adb_command, shell=True)def get_emulators():    emulator_list.clear()    adb_command = f"adb devices"    result = subprocess.run(adb_command, capture_output=True, text=True, check=True, shell=True)    if len(result.stdout) > 0:        for line in result.stdout.split("\n"):            if EMULATOR_KEY in line:                emulator_list.append({EMULATOR_KEY: line.split("\t")[0], STATE_KEY: line.split("\t")[1]})def check_emulator_offline(emulator_device):    if emulator_device['state'] == "offline":        print(f"EMULATOR {emulator_device['emulator']} IS OFFLINE")        exit(1)    else:        return Falsedef are_images_similar(first_image, second_image):    compare_image = CompareImage(first_image, second_image)    image_difference = compare_image.compare_image()    # print(f"Images are diferent in percent : {image_difference}")    return image_difference < 0.12def close_ad_present(emulator_device,):    take_screenshot(emulator_device)    crop_screenshot(emulator_device, CLOSE_AD_DIMENSIONS)    cropped_screenshot_path = CROPPED_SCREENSHOT_PATH + "-" + emulator_device[EMULATOR_KEY] + ".png"    return are_images_similar(cropped_screenshot_path, ORIGINAL_CLOSE_AD_IMAGE_PATH) \        or are_images_similar(cropped_screenshot_path, ORIGINAL_CLOSE_AD_IMAGE_PATH_2)def ad_present(emulator_device):    take_screenshot(emulator_device)    crop_screenshot(emulator_device, TV_IMAGE_DIMENSIONS)    cropped_screenshot_path = CROPPED_SCREENSHOT_PATH + "-" + emulator_device[EMULATOR_KEY] + ".png"    return are_images_similar(cropped_screenshot_path, ORIGINAL_TV_IMAGE_PATH)def check_device_loop(emulator):    print(f"RUNNING LOOP for {emulator}")    while True:        # check if its online        if not check_emulator_offline(emulator):            if ad_present(emulator):                print(f"EMULATOR: {emulator[EMULATOR_KEY]} has AD")                click_on_ad(emulator)                while True:                    # wait for ad                    time.sleep(2)                    # check if ad is over                    if close_ad_present(emulator):                        print(f"EMULATOR: {emulator[EMULATOR_KEY]} can EXIT AD")                        click_exit_ad(emulator)                        break                    else:                        print(f"EMULATOR: {emulator[EMULATOR_KEY]} playing ADS")            else:                # check if currently in AD                if close_ad_present(emulator):                    click_exit_ad(emulator)                else:                    print(f"EMULATOR: {emulator[EMULATOR_KEY]} has NO AD")        else:            exit(1)if __name__ == '__main__':    # get all emulators and check their state    get_emulators()    thread_list = []    if len(emulator_list) == 0:        print("No running emulators, exiting")        exit(1)    for device in emulator_list:        thread = threading.Thread(target=check_device_loop, args=(device,))        thread.daemon = True  # Set the thread as a daemon (so it exits when the main program exits)        thread.start()        thread_list.append(thread)    for thread in thread_list:        thread.join()